from generation import *
import json


class AssemblyMismatch(Exception):
    """Assembly mismatch exception.
    This exception is raised when a saved instructions differ from current instructions

    Args:
        Exception (str): Expected instructions (with date of the last update) and actual instructions
    """
    def __init__(self, f, expected, actual, last_update, difference, *args: object) -> None:
        super().__init__(*args)
        self.function = f
        self.expected = expected
        self.actual = actual
        self.last_update = last_update
        self.difference = difference

    def format_instructions(self, instr):
        s = ""
        for i in instr:
            s = s + '\t' + i + '\n'
        return s

    def __str__(self) -> str:
        s1 = f'-------------------------------------------------\nAssembly mismatch with function : {self.function}\n\n'

        if len(self.expected) < 10:
            s2 = f'Expecting (saved {self.last_update}):\n' + self.format_instructions(self.expected) + '\n'
            s3 = 'Got:\n' + self.format_instructions(self.actual)
        else:
            s2 = f'Instruction {self.difference + 1}\nExpecting {self.expected[self.difference]}\n\n'
            s3 = f'Got {self.actual[self.difference]}'

        return s1 + s2 + s3


def find_difference(l1, l2):
    for i in range(0, min(len(l1), len(l2))):
        if l1[i] != l2[i]:
            return i
    return -1


def get_saved_functions():
    """Return saved functions as dictionary

    Returns:
        dict: a dictionary that corresponds to json file containing the functions
    """
    f = load_json()
    funcDict = json.loads(f)

    return funcDict



def validate(select='all', raise_exception=False):
    """Check if instructions generated by current version of eve library 
    correspond to saved instructions

    Args:
        select (str, optional): If `all`, check all functions, otherwise check the selected function. Defaults to 'all'.
        raise_exception (bool, optional): If `True` raises exception that will interrupt the execution, otherwise
         print error and return False. Defaults to False.

    Raises:
        AssemblyMismatch: If raise_exception=True and new assembly differs from saved assembly this exception is raised

    Returns:
        bool: `True` if new instructions correspond to saved instructions, otherwise `False`
    """
    conf = load_config()
    confDict = json.loads(conf)

    functions = [(k, confDict[k]) for k in dict.keys(confDict)]
    functions_assembly = extract_assembly.get_functions_instructions(functions, keep_tmp=False)

    validationSet = get_saved_functions()

    ret = True

    for k in dict.keys(functions_assembly):
        if functions_assembly[k] != validationSet[k]['instr']:
            diff = find_difference(functions_assembly[k], validationSet[k]['instr'])
            if raise_exception:
                raise AssemblyMismatch(k, validationSet[k]['instr'], functions_assembly[k], validationSet[k]['date'], diff)
            else:
                e = AssemblyMismatch(k, validationSet[k]['instr'], functions_assembly[k], validationSet[k]['date'], diff)
                print(e.__str__())
                ret = False
    return ret


if __name__ == '__main__':
    validate()