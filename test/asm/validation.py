from generation import *
import json
import os
import reader
import files

LOG_PATH = "test/asm/log.txt"


class AssemblyMismatch(Exception):
    """Assembly mismatch exception.
    This exception is raised when a saved instructions differ from current instructions

    Args:
        Exception (str): Expected instructions (with date of the last update) and actual instructions
    """
    def __init__(self, function, compiler, arch, expected, actual, *args: object) -> None:
        super().__init__(*args)
        self.function = function
        self.compiler = compiler
        self.arch = arch
        self.expected = expected
        self.actual = actual

    def format_instructions(self, instr):
        s = ""
        for i in instr:
            s = s + '\t' + i['instr'] + '\n'
        return s

    def __str__(self) -> str:
        print(self.actual)
        print(self.expected)
        s0 = f'-------------------------------------------------\nAssembly mismatch with function : {self.function}\n\n'
        s1 = f'Compiler : {self.compiler}\nArchitecture : {self.arch}\n'
        #s2 = 'Expecting :\n' + self.format_instructions(self.expected) + '\n'
        #s3 = 'Got:\n' + self.format_instructions(self.actual) + '\n'

        return s0 + s1 #+ s2 + s3



def log_string(function:str, compiler:str, arch:str, expected:list, actual:list):
    """Generates a fromatted string describing errors on a function.\n
    This formatted string is used for log file.

    Args:
        f (str): Function name
        expected (list): List of expected instructions
        actual (list): List of actual instructions
        save_date (str): Date of the last update of the function

    Returns:
        str: Fromatted string
    """

    s = f'-----------------------------\nFunction : {function}\nCompiler : {compiler}\nArchitecture : {arch}\n'
    s += f'\n\n\tExpected\tActual\n\n'
    for i in range(0, max(len(expected), len(actual))):
        if len(expected) <= i:
            s += f'--> ____ \t--> {actual[i]}\n'
        elif len(actual) <= i:
            s += f'--> {expected[i]} \t--> ____\n'
        else:
            if expected[i] != actual[i]:
                s += f'--> {expected[i]}\t--> {actual[i]}\n'
            else:
                s += f'\t{expected[i]}\t{actual[i]}\n'

    return s + '\n\n\n'



def validate(input='all', raise_exception=False, log_file=False, keep_tmp=False):
    """Checks if instructions generated by current version of eve library 
    correspond to saved instructions

    Args:
        select (list, optional): If `all`, checks all functions, otherwise checks only selected function. Defaults to 'all'.
        raise_exception (bool, optional): If `True` raises exception that will interrupt the execution, otherwise 
        prints error and returns False. Defaults to False.
        log_file (bool, optional): If `True` generates a log file. Defaults to False.

    Raises:
        AssemblyMismatch: If raise_exception=True and new assembly differs from saved assembly this exception is raised

    Returns:
        bool: `True` if new instructions correspond to saved instructions, otherwise `False`
    """
    files.build_reference_directories()

    conf = reader.read_config_file(input)

    functions = []
    for k in conf.keys():
        for typ in conf[k]:
            functions.append((k, typ))

    functions_assembly = extract_assembly.get_functions_instructions(functions, keep_tmp=keep_tmp)
    
    validation_set = reader.read_reference_files(input)
    
    ret = 0

    log_txt = ""

    for f in conf.keys():
        for c in const.COMPILER:
            for a in const.ARCH:
                if f not in validation_set[c][a].keys():
                    print(f"**WARNING** - Function {f} not found in references (comp {c}, arch {a}). Try generating using option -g.")
                elif not functions_assembly[c][a][f] == validation_set[c][a][f]:
                    if raise_exception:
                        raise AssemblyMismatch(f, c, a, validation_set[c][a][f], functions_assembly[c][a][f])
                    log_txt += log_string(f, c, a, validation_set[c][a][f], functions_assembly[c][a][f])
                    ret = -1

    # Log file optional
    if log_file and log_txt != "":
        if os.path.exists(LOG_PATH):
            file = open(LOG_PATH, 'w')
        else:
            file = open(LOG_PATH, 'x')
        file.write(log_txt)
        file.close()

    return ret


if __name__ == '__main__':
    print(validate(input='all', log_file=True, raise_exception=True, keep_tmp=True))