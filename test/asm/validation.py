from generation import *
import json


class AssemblyMismatch(Exception):
    """Assembly mismatch exception.
    This exception is raised when a saved instructions differ from current instructions

    Args:
        Exception (str): Expected instructions (with date of the last update) and actual instructions
    """
    def __init__(self, f, expected, actual, last_update, *args: object) -> None:
        super().__init__(*args)
        self.function = f
        self.expected = expected
        self.actual = actual
        self.last_update = last_update

    def format_instructions(self, instr):
        s = ""
        for i in instr:
            s = s + '\t' + i + '\n'
        return s

    def __str__(self) -> str:
        s1 = f'Assembly mismatch with function : {self.function}\n\n'
        s2 = f'Expecting (saved {self.last_update}):\n' + self.format_instructions(self.expected) + '\n'
        s3 = 'Got:\n' + self.format_instructions(self.actual)

        return s1 + s2 + s3



def get_saved_functions():
    """Return saved functions as dictionary

    Returns:
        dict: a dictionary that corresponds to json file containing the functions
    """
    f = load_json()
    funcDict = json.loads(f)

    return funcDict



def validate(select='all', raise_exception=False):
    """Check if instructions generated by current version of eve library 
    correspond to saved instructions

    Args:
        select (str, optional): If `all`, check all functions, otherwise check the selected function. Defaults to 'all'.
        raise_exception (bool, optional): If `True` raises exception that will interrupt the execution, otherwise
         print error and return False. Defaults to False.

    Raises:
        AssemblyMismatch: If raise_exception=True and new assembly differs from saved assembly this exception is raised

    Returns:
        bool: `True` if new instructions correspond to saved instructions, otherwise `False`
    """
    conf = load_config()
    confDict = json.loads(conf)

    functions = [(k, confDict[k]) for k in dict.keys(confDict)]
    functions_assembly = extract_assembly.get_functions_instructions(functions, keep_tmp=False)

    validationSet = get_saved_functions()

    for k in dict.keys(functions_assembly):
        if functions_assembly[k] != validationSet[k]['instr']:
            if raise_exception:
                raise AssemblyMismatch(k, validationSet[k]['instr'], functions_assembly[k], last_update=validationSet[k]['date'])
            else:
                e = AssemblyMismatch(k, validationSet[k]['instr'], functions_assembly[k], last_update=validationSet[k]['date'])
                print(e.__str__())
                return False
    return True


if __name__ == '__main__':
    validate()